/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.generator

import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.xtext.example.mylang.AndExpr
import org.xtext.example.mylang.Assign
import org.xtext.example.mylang.Block
import org.xtext.example.mylang.CmpExpr
import org.xtext.example.mylang.Expression
import org.xtext.example.mylang.FinalExpr
import org.xtext.example.mylang.FunctionCall
import org.xtext.example.mylang.FunctionDecl
import org.xtext.example.mylang.If
import org.xtext.example.mylang.MulExpr
import org.xtext.example.mylang.PlusExpr
import org.xtext.example.mylang.Program
import org.xtext.example.mylang.Return
import org.xtext.example.mylang.TYPE
import org.xtext.example.mylang.VariableDecl
import org.xtext.example.mylang.While

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
abstract class Name {		
	public TYPE type;
	public String name;
}

class Variable extends Name {
	public String pointer; // either name or ebp + offset
	
	new (TYPE type, String name, String pointer) {
		this.type = type;
		this.name = name;
		this.pointer = pointer;
	}
} 

class Func extends Name {
	public List<Pair<TYPE,String>> args;
	
	new (TYPE type, String name, List<Pair<TYPE,String>> args) {
		this.type = type;
		this.name = name;
		this.args = args;
	}
} 

class Array extends Name {
	public int size;
	public String pointer;
	
	new(TYPE type, String name, String pointer, int size) {
		this.type = type;
		this.name = name;
		this.size = size;
		this.pointer = pointer;
	}
	
}
	
class MylangGenerator extends AbstractGenerator {
	val String errVariableRedefine = "variable/function with the same name exist"
	val String errBadType = "Bad type"
	val String errNoMain = "No main() function"
	
	def String getLine(EObject e) {
		return " at line " + NodeModelUtils.getNode(e).startLine.toString;
	}
	
	var Map<String, Name> variables = newLinkedHashMap();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var tree = resource.contents;
		if (tree.size == 1) {
			var e = tree.get(0);
			if (e instanceof Program) {
				try {
					fsa.generateFile(resource.URI.lastSegment.replace(".lang", ".asm"), e.walk);
				} catch (Exception exp) {
					fsa.generateFile('error.txt', exp.message);
				}
			}
		}
	}
	
	def String walk(Program p) {
		var String ans = '''
		extern printf
		section .data
			int_format db "%d ", 0
		'''
		for (decl : p.declarations) {
			if (decl instanceof VariableDecl) {
				if (variables.containsKey(decl.name)) {
					throw new Exception(errVariableRedefine + getLine(decl));
				}
				ans += "\t" + decl.name;
				if (decl.array) {
					variables.put(decl.name, new Array(decl.type, decl.name, decl.name, decl.size));
					ans += " times " + decl.size;
				} else {
					variables.put(decl.name, new Variable(decl.type, decl.name, decl.name));
				}
				ans +=  " dd 0\n"
			}	
		}
		ans += '''
		section .text
		global _main
		 
		_write:
			TODO
			
		_read:
			TODO
		 
		'''
		variables.put("write", new Func(TYPE.VOID, "write", newLinkedList(new Pair(TYPE.INTEGER, "arg"))));
		variables.put("read", new Func(TYPE.INTEGER, "read", newLinkedList()));
		for (decl : p.declarations) {
			if (decl instanceof FunctionDecl) {
				if (variables.containsKey(decl.name)) {
					throw new Exception(errVariableRedefine + getLine(decl));
				}
				ans += "_" + decl.name + ':\n';
				var List<Pair<TYPE, String>> args = newLinkedList();
				for (arg : decl.argList) {
					args.add(new Pair(arg.type, arg.name));
				}
				variables.put(decl.name, new Func(decl.type, decl.name, args));
				ans += walk(decl);
			}	
		}
		if (!(variables.get("main") instanceof Func)) {
			throw new Exception(errNoMain);
		}
		ans;
	}
	//functions take its args from stack and return value int eax
	def String walk(FunctionDecl e) {
		var List<String> scope = newLinkedList();
		for (arg : e.argList) {
			scope.add(arg.name);
			variables.put(arg.name, new Variable(arg.type, arg.name, "TODO"));
		}
		var ans = walk(e.body, "_" + e.name);
		for (variable : scope) {
			variables.remove(variable)
		}
		ans + "\n";
	}
	
	
	//
	//
	//stopped here
	def String walk(Block e, String mark) {
		var List<String> scope = newLinkedList();
		var String ans = "";
		var ifCounter = 0;
		var whileCounter = 0;
		for (command : e.commands) {
			switch command {
				VariableDecl: {
					if (variables.containsKey(command.name)) {
						throw new Exception(errVariableRedefine + getLine(command));
					}
					scope.add(command.name);
					variables.put(command.name, new Variable(command.type, command.name, "TODO"));
				}
				Assign: {
					ans += walk(command.expression);
					ans += "\tpop eax\n"
					ans += "\tmov TODO eax\n"
				}
				If: {
					ifCounter++
					ans += walk(command.condition)
					ans += "\tpop eax\n"
					ans += "\tcmp eax, 1\n"
					ans += "\tjne "
					if (command.isElse) {
						ans += mark + "_else" + ifCounter + "\n";
						ans += walk(command.body, mark + "_if" + ifCounter)
						ans += "\tjmp " + mark + "_endif" + ifCounter + "\n"
						ans += mark + "_else" + ifCounter + ":\n"
						ans += walk(command.elseBody, mark + "_else" + ifCounter)
					} else {
						ans += mark + "_endif" + ifCounter + "\n"
						ans += walk(command.body, mark + "_if" + ifCounter)
					}
					ans += mark + "_endif:\n";
				}
				While: {
					whileCounter++;
					ans += mark + "_while" + whileCounter + ":\n"
					ans += walk(command.condition);
					ans += "\tpop eax\n"
					ans += "\tcmp eax, 1\n"
					ans += "\tjne " + mark + "_endwhile" + whileCounter + "\n"
					ans += walk(command.body, mark + "_while" + whileCounter)
					ans += mark + "_endwhile" + whileCounter + ":\n"
				}
				Return: {
					if (command.value != null) {
						ans += walk(command.value);
						ans += "\tpop eax\n";
					}
					ans += "\tret\n"
				}
				FunctionCall: {
					ans += "\tFUNCTION CALL'\n"
				}
			}
		}
		for (variable : scope) {
			variables.remove(variable)
		}
		return ans
	}
	
	//push its result on stack (4 bytes)
	def String walk(Expression e) {
		var String ans = walk(e.first)
		for (expr : e.expr) {
			ans += walk(expr);
			ans += "\tpop eax\n"
			ans += "\tor [esp], eax\n"
		}
		return ans
	}
	
	//push its result on stack (4 bytes)
	def String walk(AndExpr e) {
		var String ans = walk(e.first)
		for (expr : e.expr) {
			ans += walk(expr);
			ans += "\tpop eax\n"
			ans += "\tand [esp], eax\n"
		}
		return ans
	}
	
	// push its result on stack (4 bytes)
	def String walk(CmpExpr e) {
		var String ans = walk(e.first)
		if (e.second != null) {
			ans += walk(e.second)
			ans += "\tpop eax\n"
			ans += "\tpop ebx\n"
			ans += "\tcmp eax, ebx\n"
			ans += "\tTODOcmp\n"
			ans += "\tpush eax\n"
		}
		ans
	}
	
	// push its result on stack (4 bytes)
	def String walk(PlusExpr e) {
		var String ans = walk(e.first)
		for (expr : e.expr) {
			ans += walk(expr);
			ans += "\tpop eax\n"
			ans += "\tadd [esp], eax\n"
		}
		return ans
	}
	
	// push its result on stack (4 bytes)
	def String walk(MulExpr e) {
		var String ans = walk(e.first)
		for (expr : e.expr) {
			ans += walk(expr);
			ans += "\tpop eax\n"
			ans += "\tmul [esp], eax\n"
		}
		return ans
	}
	
	def String walk(FinalExpr e) {
		if (e instanceof FunctionCall) {
			return "\tTODO\n"
		} else if (e.expr != null) {
			return walk(e.expr);
		} else if (e.variable != null) {
			return "\tTODO VAR\n"
		} else {
			var String ans = "\tmov eax, " + e.number + "\n"
			ans += "\tpush eax\n"
			return ans;
		}
	}
	
	def String walk(FunctionCall e) '''
		«FOR arg : e.args.reverse»
		«»
			«walk(arg)»
		«ENDFOR»
			call «e.name»
	'''
} 
