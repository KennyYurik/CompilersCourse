/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.generator

import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.xtext.example.mylang.AndExpr
import org.xtext.example.mylang.Assign
import org.xtext.example.mylang.Block
import org.xtext.example.mylang.CmpExpr
import org.xtext.example.mylang.Expression
import org.xtext.example.mylang.FinalExpr
import org.xtext.example.mylang.FunctionCall
import org.xtext.example.mylang.FunctionDecl
import org.xtext.example.mylang.If
import org.xtext.example.mylang.MulExpr
import org.xtext.example.mylang.PlusExpr
import org.xtext.example.mylang.Program
import org.xtext.example.mylang.Return
import org.xtext.example.mylang.TYPE
import org.xtext.example.mylang.VariableDecl
import org.xtext.example.mylang.While

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
abstract class Name {		
	public TYPE type;
	public String name;
}

class Variable extends Name {
	public String pointer; // either name or ebp + offset
	
	new (TYPE type, String name, String pointer) {
		this.type = type;
		this.name = name;
		this.pointer = pointer;
	}
} 

class Func extends Name {
	public List<Pair<TYPE,String>> args;
	
	new (TYPE type, String name, List<Pair<TYPE,String>> args) {
		this.type = type;
		this.name = name;
		this.args = args;
	}
} 

class Array extends Name {
	public int size;
	public String pointer;
	
	new(TYPE type, String name, String pointer, int size) {
		this.type = type;
		this.name = name;
		this.size = size;
		this.pointer = pointer;
	}
	
}
	
class MylangGenerator extends AbstractGenerator {
	val String errVariableRedefine = "variable\function with the same name exist"
	val String errBadType = "Bad type"
	val String errNoMain = "No main() function"
	
	def String getLine(EObject e) {
		return NodeModelUtils.getNode(e).startLine.toString;
	}
	
	var Map<String, Name> variables = newLinkedHashMap();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var tree = resource.contents;
		if (tree.size == 1) {
			var e = tree.get(0);
			if (e instanceof Program) {
				try {
					fsa.generateFile(resource.URI.lastSegment.replace(".lang", ".asm"), e.walk);
				} catch (Exception exp) {
					fsa.generateFile('error.txt', exp.message);
				}
			}
		}
	}
	
	/*def String checkCorrect(Program p) {
		for (decl : p.declarations) {
			if (variables.containsKey(decl.name)) {
				return errVariableRedefine;
			} 
			if (decl instanceof VariableDecl) {
				if ()
			}
		}
		return ""
	}*/
	
	def String walk(Program p) {
		var String ans = '''
		extern printf
		section .data
			int_format db "%d ", 0
		'''
		if (p.declarations == null)
			return "";
		for (decl : p.declarations) {
			if (decl instanceof VariableDecl) {
				if (variables.containsKey(decl.name)) {
					throw new Exception(errVariableRedefine);
				}
				ans += "\t" + decl.name;
				if (decl.array) {
					variables.put(decl.name, new Array(decl.type, decl.name, decl.name, decl.size));
					ans += " times " + decl.size;
				} else {
					variables.put(decl.name, new Variable(decl.type, decl.name, decl.name));
				}
				ans +=  " dd 0\n"
			}	
		}
		ans += '''
		section .text
		global _main
		_write:
			TODO
		_read:
			TODO
		'''
		variables.put("write", new Func(TYPE.VOID, "write", newLinkedList(new Pair(TYPE.INTEGER, "arg"))));
		variables.put("read", new Func(TYPE.INTEGER, "read", newLinkedList()));
		for (decl : p.declarations) {
			if (decl instanceof FunctionDecl) {
				if (variables.containsKey(decl.name)) {
					throw new Exception(errVariableRedefine);
				}
				ans += "_" + decl.name + ':\n';
				var List<Pair<TYPE, String>> args = newLinkedList();
				for (arg : decl.argList) {
					args.add(new Pair(arg.type, arg.name));
				}
				variables.put(decl.name, new Func(decl.type, decl.name, args));
				ans += walk(decl);
			}	
		}
		if (!(variables.get("main") instanceof Func)) {
			throw new Exception(errNoMain);
		}
		ans;
	}
	//functions take its args from stack and return value int eax
	def String walk(FunctionDecl e) {
		var String[] scope;
		if (e.argList == null)
			return ""
		for (arg : e.argList) {
			scope.add(arg.name);
			variables.put(arg.name, new Variable(arg.type, arg.name, "TODO"));
		}
		var ans = walk(e.body, "_" + e.name);
		for (variable : scope) {
			variables.remove(variable)
		}
		ans;
	}
	
	
	//
	//
	//stopped here
	def String walk(Block e, String mark) {
		var String[] scope;
		var String ans = "";
		var ifCounter = 0;
		var whileCounter = 0;
		if (e.commands == null)
			return "";
		for (command : e.commands) {
			switch command {
				VariableDecl: {
					if (variables.containsKey(command.name)) {
						throw new Exception(errVariableRedefine);
					}
					scope.add(command.name);
					variables.put(command.name, new Variable(command.type, command.name, "TODO"));
				}
				Assign: {
					ans += walk(command.expression);
					ans += '''
					«»
						pop eax
						mov «variables.get(command).name» eax
					'''
				}
				If: {
					ifCounter++
					ans += walk(command.condition)
					ans += "\tpop eax\n"
					ans += "\tcmp eax, 1"
					ans += "\tjne "
					if (command.isElse) {
						ans += mark + "_else" + ifCounter + "\n";
						ans += walk(command.body, mark + "_if" + ifCounter)
						ans += "\tjmp " + mark + "_endif" + ifCounter + "\n"
						ans += mark + "_else" + ifCounter + ":\n"
						ans += walk(command.elseBody, mark + "_else" + ifCounter)
					} else {
						ans += mark + "_endif" + ifCounter + "\n"
						ans += walk(command.body, mark + "_if" + ifCounter)
					}
					ans += mark + "_endif:\n";
				}
				While: {
					whileCounter++;
					ans += mark + "_while" + whileCounter + ":\n"
					ans += walk(command.condition);
					ans += "\tpop eax\n"
					ans += "\tcmp eax, 1"
					ans += "\tjne " + mark + "_endwhile" + whileCounter + "\n"
					ans += walk(command.body, mark + "_while" + whileCounter)
					ans += mark + "_endwhile" + whileCounter + ":\n"
				}
				Return: {
					ans += "\tret\n"
				}
				FunctionCall: {
					ans += "\tTODO'\n"
				}
			}
		}
		for (variable : scope) {
			variables.remove(variable)
		}
		return ans
	}
	
	//push its result on stack (4 bytes)
	def String walk(Expression e) {
		var String ans = ""//walk(e.first)
		if (e.expr == null) {
			return ans;
		}
		for (expr : e.expr) {
			ans += ""//walk(expr);
			ans += "\tpop eax\n"
			ans += "\tor [esp], eax\n"
		}
		return ans
	}
	//push its result on stack (4 bytes)
	def String walk(AndExpr e) '''
			«walk(e.first)»
		«FOR expr : e.expr»
		
			«walk(expr)»
			pop eax
			and [esp], eax
		«ENDFOR»
	'''
	
	// push its result on stack (4 bytes)
	def String walk(CmpExpr e) '''
			«walk(e.first)»
		«IF e.second != null»
		
			«walk(e.second)»
			pop eax
			pop ebx
			cmp eax, ebx
			TODO
			push eax
		«ENDIF»
	'''
	
	// push its result on stack (4 bytes)
	def String walk(PlusExpr e) '''
			«walk(e.first)»
		«FOR expr : e.expr»
		
			«walk(expr)»
			pop eax
			add [esp], eax
		«ENDFOR»
	'''
	
	// push its result on stack (4 bytes)
	def String walk(MulExpr e) '''
			«walk(e.first)»
		«FOR expr : e.expr»
			«walk(expr)»
			pop eax
			mul [esp], eax TODO
		«ENDFOR»
	'''
	
	def String walk(FinalExpr e) {
		if (e instanceof FunctionCall) {
			return "\tTODO\n"
		} else if (e.expr != null) {
			return walk(e.expr);
		} else if (e.variable != null) {
			return "\tTODO VAR\n"
		} else {
			var String ans = '''
				«»
					mov eax, «e.number»
					push eax
			'''
			return ans;
		}
	}
	
	def String walk(FunctionCall e) '''
		«FOR arg : e.args.reverse»
		«»
			«walk(arg)»
		«ENDFOR»
			call «e.name»
	'''
} 
